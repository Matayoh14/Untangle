//
// UntanglePanel.java
// Implements the main drawing panel of the untangle game.
//
package untangle;

import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.List;
import static untangle.UntanglePoint.DISPLAY_FACTOR;

// main drawing panel for the untangle game
public class UntanglePanel extends javax.swing.JPanel {

    //Constrctor
    public UntanglePanel() {
        initComponents();

    }

    // Swictches in and out of show solution mode and repaints
    public boolean ToggleSolution() {
        show_solution = !show_solution;
        invalidate();
        repaint();
        return (show_solution);
    }

    // Swictches in and out of show intersections mode and repaints
    public boolean ToggleIntersecting() {
        show_intersecting = !show_intersecting;
        invalidate();
        repaint();
        return (show_intersecting);
    }

    // Set the grid to display and repaints
    public void setGrid(UntanglePoint[][] pts) {
        grid = pts;
        side = pts.length;

        invalidate();
        repaint();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(255, 255, 255));
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });
        setLayout(null);
    }// </editor-fold>//GEN-END:initComponents

    // Handle the pressing the left mouse button 
    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed

        int display_offset = (show_solution) ? 1 : DISPLAY_FACTOR;
        int display_scale = side * 2 * display_offset;

        if (grid != null) {
            // For each point on the grid (it is a 2D array, so 2 for loops)
            for (UntanglePoint[] pt_col : grid) {
                for (UntanglePoint pt : pt_col) {
                    if (pt != null) {
                        // Determine if the user has clicked on the point
                        Point disp_pt = pt.GetDisplayPoint(show_solution);
                        int xpos = (((disp_pt.x * 2) + display_offset) * (int) cliprect.getWidth()) / display_scale;
                        int ypos = (((disp_pt.y * 2) + display_offset) * (int) cliprect.getHeight()) / display_scale;

                        if (Math.abs(evt.getX() - xpos) <= NODE_RADIUS
                                && Math.abs(evt.getY() - ypos) <= NODE_RADIUS) {
                            // If yes, select it and redraw
                            ClearRubberBand();
                            SelectedNode = pt;
                            invalidate();
                            repaint();

                            // If in query mode show the solution grid
                            if (query) {
                                show_solution = true;
                            }
                            return;
                        }
                    }
                }
            }

            // If an area has been marked on screen the check to see if we have 
            //  click on one of the box grab handles
            pt_move_x = pt_move_y = null;
            if (showhandles) {
                Point pt = evt.getPoint();

                if (Math.abs(pt.x - rubberbandBoxStart.x) < 3 // top-left
                        && Math.abs(pt.y - rubberbandBoxStart.y) < 3) {
                    pt_move_x = pt_move_y = rubberbandBoxStart;
                } else if (Math.abs(pt.x - rubberbandBoxEnd.x) < 3 // bottom-right
                        && Math.abs(pt.y - rubberbandBoxEnd.y) < 3) {
                    pt_move_x = pt_move_y = rubberbandBoxEnd;
                } else if (Math.abs(pt.x - rubberbandBoxStart.x) < 3 //bottom-left
                        && Math.abs(pt.y - rubberbandBoxEnd.y) < 3) {
                    pt_move_x = rubberbandBoxStart;
                    pt_move_y = rubberbandBoxEnd;
                } else if (Math.abs(pt.x - rubberbandBoxEnd.x) < 3 // top-right
                        && Math.abs(pt.y - rubberbandBoxStart.y) < 3) {
                    pt_move_x = rubberbandBoxEnd;
                    pt_move_y = rubberbandBoxStart;
                }
                if (pt_move_x != null && pt_move_y != null) {
                    draghandle = true;
                    return;
                }
            }

            // If not rubberbanding and pre-requisites for rubberbanding set
            //  start the rubber band selection
            ClearRubberBand();
            rubberbandBoxStart = new Point(evt.getPoint());
            pt_move_x = pt_move_y = rubberbandBoxEnd = new Point(evt.getPoint());
            showhandles = false;
            repaint();

        }

    }//GEN-LAST:event_formMousePressed

    // Handle the user releasing the left mouse button
    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased

        // Handle rubberbanding
        if (rubberbandBoxStart != null) {
            if (!draghandle) {
                // Rubber band not big enough or the rubber band doesn't enclose any points
                if (Math.abs(rubberbandBoxEnd.x - rubberbandBoxStart.x) < 6
                        || Math.abs(rubberbandBoxEnd.y - rubberbandBoxStart.y) < 6
                        || !AddPointsToRubberBand()) {
                    ClearRubberBand();
                } else {
                    pt_move_x = pt_move_y = null;
                    showhandles = true;
                }
            }
            draghandle = false;

            CheckSolution();

            invalidate();
            repaint();
        }

        // If dragging a point or in query node, unselect it
        if (SelectedNode != null) {
            if (query) {
                show_solution = false;
            }
            SelectedNode = null;

            invalidate();
            repaint();

            CheckSolution();

        }
    }//GEN-LAST:event_formMouseReleased

    // call the parent check solution method
    public void CheckSolution() {
        Component c = this;

        while ((c = c.getParent()) != null) {
            if (c instanceof UntangleFrm) {
                ((UntangleFrm) c).checkSolution();
                break;
            }
        }
    }

    // Convert from screen to logical co-ordinates
    public Point FromScreen(Point pt) {
        int display_offset = ((show_solution) ? 1 : DISPLAY_FACTOR);
        int display_scale = side * 2 * display_offset;

        return new Point(
                ((pt.x * display_scale) / (int) cliprect.getWidth() - DISPLAY_FACTOR) / 2,
                ((pt.y * display_scale) / (int) cliprect.getHeight() - DISPLAY_FACTOR) / 2);
    }

    // If rubberband selected, get all points in the selected area
    public boolean AddPointsToRubberBand() {

        // convert the rubber band to logical co-ordinates
        Point rbs = FromScreen(rubberbandBoxStart);
        Point rbe = FromScreen(rubberbandBoxEnd);
        Point Start = FromScreen(rubberbandBoxStart);
        Point End = FromScreen(rubberbandBoxEnd);

        // Normalise the rectangle (makes the next check simpler)
        if (rbs.x > rbe.x) {
            int tmp = rbs.x;
            rbs.x = rbe.x;
            rbe.x = tmp;
        }
        if (rbs.y > rbe.y) {
            int tmp = rbs.y;
            rbs.y = rbe.y;
            rbe.y = tmp;
        }

        // For each point
        for (UntanglePoint[] pt_col : grid) {
            for (UntanglePoint pt : pt_col) {
                if (pt != null) {
                    // Determine if oint in box
                    Point disp_pt = pt.GetDisplayPoint(show_solution);

                    if (disp_pt.x >= rbs.x && disp_pt.y >= rbs.y
                            && disp_pt.x <= rbe.x && disp_pt.y <= rbe.y) {
                        BandSelectedNodes.add(pt);
                        pt.StartRubberBand(Start, End);
                    }
                }
            }

        }
        return BandSelectedNodes.size() > 0;
    }

    // Handle the mouse being dragged (moved while the left mouse button is held)
    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        //Stop points being dragged off screen
        int x = Math.max(Math.min(evt.getX(), (int) cliprect.getWidth() - NODE_RADIUS), NODE_RADIUS);
        int y = Math.max(Math.min(evt.getY(), (int) cliprect.getHeight() - NODE_RADIUS), NODE_RADIUS);

        // If in solution mode you can highlight points but not drag them
        if (SelectedNode != null && !show_solution) {
            int display_scale = side * 2 * DISPLAY_FACTOR;

            int xpos = ((x * display_scale) / (int) cliprect.getWidth() - DISPLAY_FACTOR) / 2;
            int ypos = ((y * display_scale) / (int) cliprect.getHeight() - DISPLAY_FACTOR) / 2;

            SelectedNode.MoveTo(xpos, ypos);
            invalidate();
            repaint();
        }

        // Determine if dragging a rubber band box drag handle
        if (pt_move_x != null && pt_move_y != null) {
            pt_move_x.x = x;
            pt_move_y.y = y;

            Point start = FromScreen(rubberbandBoxStart);
            Point end = FromScreen(rubberbandBoxEnd);

            BandSelectedNodes.forEach((n) -> {
                n.ProcessRubberBand(start, end);
            });
            repaint();

        }
    }//GEN-LAST:event_formMouseDragged

    // Remove the rubber band box
    public void ClearRubberBand() {
        rubberbandBoxStart = null;
        rubberbandBoxEnd = null;
        showhandles = false;
        pt_move_x = pt_move_y = null;
        BandSelectedNodes.clear();
    }

    // Set as solved and redraw (all points will turn green)
    public void SetSolved(boolean solved) {
        this.solved = solved;
        repaint();
    }

    // Set query mode
    public void SetQuery(boolean state) {
        query = state;
    }

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);

        //  Get the drawing rect
        cliprect = g.getClipBounds();

        if (grid != null) {
            // If rubberbanding draw the rubberband
            if (rubberbandBoxStart != null && rubberbandBoxEnd != null) {
                // set dimensions since drawRect() only draws in the fourth quadrant
                int x = Math.min(rubberbandBoxStart.x, rubberbandBoxEnd.x);
                int y = Math.min(rubberbandBoxStart.y, rubberbandBoxEnd.y);
                int width = Math.abs(rubberbandBoxEnd.x - rubberbandBoxStart.x);
                int height = Math.abs(rubberbandBoxEnd.y - rubberbandBoxStart.y);

                // draw the rubber band box
                g.setColor(RUBBERBAND_FILL); // translucent cyan
                g.fillRect(x, y, width, height);
                g.setColor(Color.blue); // blue outline
                g.drawRect(x, y, width, height);

                // draw the grab handles
                if (showhandles) {
                    g.fillRect(rubberbandBoxStart.x - 3, rubberbandBoxStart.y - 3, 6, 6);
                    g.fillRect(rubberbandBoxStart.x - 3, rubberbandBoxEnd.y - 3, 6, 6);
                    g.fillRect(rubberbandBoxEnd.x - 3, rubberbandBoxStart.y - 3, 6, 6);
                    g.fillRect(rubberbandBoxEnd.x - 3, rubberbandBoxEnd.y - 3, 6, 6);
                }

            }
            int display_offset = ((show_solution) ? 1 : DISPLAY_FACTOR);
            int display_scale = side * 2 * display_offset;

            // If showing intersecting lines, use the line segments as this contains the
            //  intersection info
            if (show_intersecting && !show_solution) {

                for (LineSegment l : lines) {
                    // draw black if not intersecting, else red
                    g.setColor((l.crosses == 0) ? Color.BLACK : Color.RED);

                    int xpos1 = (((l.end1.x * 2) + display_offset) * (int) cliprect.getWidth()) / display_scale;
                    int ypos1 = (((l.end1.y * 2) + display_offset) * (int) cliprect.getHeight()) / display_scale;
                    int xpos2 = (((l.end2.x * 2) + display_offset) * (int) cliprect.getWidth()) / display_scale;
                    int ypos2 = (((l.end2.y * 2) + display_offset) * (int) cliprect.getHeight()) / display_scale;

                    g.drawLine(xpos1, ypos1, xpos2, ypos2);

                }
            } else {
                g.setColor(Color.BLACK);

                // Draw the connecting lines
                for (int x = 0; x < side; x++) {
                    for (int y = 0; y < side; y++) {
                        if (grid[x][y] != null) {

                            Point pt = grid[x][y].GetDisplayPoint(show_solution);
                            int xpos = (((pt.x * 2) + display_offset) * (int) cliprect.getWidth()) / display_scale;
                            int ypos = (((pt.y * 2) + display_offset) * (int) cliprect.getHeight()) / display_scale;

                            for (UntanglePoint connected : grid[x][y]) {
                                Point conn = connected.GetDisplayPoint(show_solution);

                                //System.out.printf("Drawing from %d, %d to %d, %d\n", x, y, conn.x, conn.x);
                                int xpos2 = (((conn.x * 2) + display_offset) * (int) cliprect.getWidth()) / display_scale;
                                int ypos2 = (((conn.y * 2) + display_offset) * (int) cliprect.getHeight()) / display_scale;

                                g.drawLine(xpos, ypos, xpos2, ypos2);

                            }

                        }
                    }
                }
            }

            // Draw the nodes
            int diameter = NODE_RADIUS * 2 + 1;
            for (int x = 0; x < side; x++) {
                for (int y = 0; y < side; y++) {
                    if (grid[x][y] != null) {

                        Point pt = grid[x][y].GetDisplayPoint(show_solution);
                        int xpos = (((pt.x * 2) + display_offset) * (int) cliprect.getWidth()) / display_scale;
                        int ypos = (((pt.y * 2) + display_offset) * (int) cliprect.getHeight()) / display_scale;

                        Color color = NODE_COLOR;
                        //if (SelectedNode != null) {
                        if (solved && !show_solution) {
                            color = NODE_SOLVED_COLOR;
                        } else if (grid[x][y] == SelectedNode || BandSelectedNodes.contains(grid[x][y])) {
                            color = NODE_SELECTED_COLOR;
                        } else if (grid[x][y].ConnectedTo(SelectedNode)) {
                            color = NODE_CONNECTED_COLOR;
                            // }
                        }
                        g.setColor(color);
                        g.fillOval(xpos - NODE_RADIUS, ypos - NODE_RADIUS, diameter, diameter);
                        g.setColor(Color.BLACK);
                        g.drawOval(xpos - NODE_RADIUS, ypos - NODE_RADIUS, diameter, diameter);

                    }

                }
            }
        }
    }

    private UntanglePoint[][] grid;   // grid of points
    public List<LineSegment> lines;   // set of lines
    private UntanglePoint SelectedNode;   // node being dragged
    private final List<UntanglePoint> BandSelectedNodes = new ArrayList<>(); // Nodes in rubber band
    private int side;
    private Rectangle cliprect;     // Clip rectangle for the panel
    private boolean show_solution = false;   // Drawing options
    private boolean show_intersecting = false;
    private boolean query = false;
    private boolean draghandle = false;
    private boolean solved = false;

    // Colours
    private static final Color NODE_COLOR = new Color(175, 238, 238);
    private static final Color NODE_SELECTED_COLOR = new Color(238, 175, 175);
    private static final Color NODE_CONNECTED_COLOR = Color.RED;
    private static final Color NODE_SOLVED_COLOR = Color.GREEN;
    private static final Color RUBBERBAND_FILL = new Color(0, 255, 255, 10);
    
    private static final int NODE_RADIUS = 4;  // Node size

    private Point rubberbandBoxStart;  // Rubber band info
    private Point rubberbandBoxEnd;
    private boolean showhandles = false;
    private Point pt_move_x = null;   // rubber band handle being dragged
    private Point pt_move_y = null;


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
