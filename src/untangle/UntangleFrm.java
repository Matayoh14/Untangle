//
// UntangleFrm.java
// Implements the main form window for tor the untangle game.
//
package untangle;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;
import static untangle.UntanglePoint.DISPLAY_FACTOR;

// Frame Window for the untangle game
public class UntangleFrm extends javax.swing.JFrame {

    // Constructor
    public UntangleFrm() {
        initComponents();

        pack();
        
        // Intersection controls initailly hidden
        IntersectLbl1.setVisible(false);
        IntersectLbl2.setVisible(false);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new UntanglePanel();
        jPanel2 = new javax.swing.JPanel();
        jGridSizeText = new java.awt.TextField();
        label1 = new java.awt.Label();
        btnCreate = new java.awt.Button();
        btnSolve = new java.awt.Button();
        jQueryChk = new java.awt.Checkbox();
        jIntersectChk = new java.awt.Checkbox();
        IntersectLbl1 = new java.awt.Label();
        IntersectLbl2 = new java.awt.Label();
        SaveBtn = new java.awt.Button();
        LoadBtn = new java.awt.Button();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        jPanel1.addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                jPanel1ComponentResized(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 703, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 622, Short.MAX_VALUE)
        );

        jGridSizeText.setText("25");

        label1.setText("Size (10-200)");

        btnCreate.setLabel("Create");
        btnCreate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCreateActionPerformed(evt);
            }
        });

        btnSolve.setEnabled(false);
        btnSolve.setLabel("Show Solution");
        btnSolve.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSolveActionPerformed(evt);
            }
        });

        jQueryChk.setEnabled(false);
        jQueryChk.setLabel("Query Mode");
        jQueryChk.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                QueryChkItemStateChanged(evt);
            }
        });

        jIntersectChk.setEnabled(false);
        jIntersectChk.setLabel("Show intersections");
        jIntersectChk.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                IntersectChkItemStateChanged(evt);
            }
        });

        IntersectLbl1.setText("Intersections");

        IntersectLbl2.setFont(new java.awt.Font("Arial Black", 0, 18)); // NOI18N
        IntersectLbl2.setForeground(new java.awt.Color(255, 0, 0));
        IntersectLbl2.setText("Intersections");

        SaveBtn.setEnabled(false);
        SaveBtn.setLabel("Save");
        SaveBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SaveBtnActionPerformed(evt);
            }
        });

        LoadBtn.setLabel("Load");
        LoadBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                LoadBtnActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(label1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jGridSizeText, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jIntersectChk, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jQueryChk, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGap(39, 39, 39)
                        .addComponent(IntersectLbl1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGap(24, 24, 24)
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(btnSolve, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(btnCreate, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(LoadBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(SaveBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel2Layout.createSequentialGroup()
                    .addGap(46, 46, 46)
                    .addComponent(IntersectLbl2, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(57, Short.MAX_VALUE)))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGap(44, 44, 44)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(label1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jGridSizeText, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(22, 22, 22)
                .addComponent(IntersectLbl1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jIntersectChk, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jQueryChk, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(23, 23, 23)
                .addComponent(LoadBtn, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(SaveBtn, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnSolve, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnCreate, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(34, 34, 34))
            .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel2Layout.createSequentialGroup()
                    .addGap(110, 110, 110)
                    .addComponent(IntersectLbl2, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(519, Short.MAX_VALUE)))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(23, 23, 23)
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, 135, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(20, 20, 20))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(25, 25, 25))
            .addComponent(jPanel2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    // Generates an a randomly ordered array of unique numbers in the rangle 0 to size-1
    //   number must be <= size
    private int[] GenerateOrder(int size, int number) {
        int[] order = new int[size];

        for (int i = 0; i < size; i++) {
            order[i] = i;
        }

        for (int j = 0; j < number; j++) {
            int swap = rand.nextInt(size--);
            int tmp = order[j];
            order[j] = order[swap + j];
            order[swap + j] = tmp;
        }
        return (order);
    }

    // Generates the grid to solve
    private void GenerateGrid() {
        // get the length of the side of the grid, such that it can fit the point and
        //  has a number of unused points
        side = (int) ((Math.sqrt(size)) * 1.6);

        ////////////////////////////////////////////////////////////////////
        // Create the mesh
        // Select random points on the grid
        pts = new UntanglePoint[side][side];

        int[] order = GenerateOrder(side * side, size);

        for (int i = 0; i < size - 1; i++) {
            int x = order[i] % side;
            int y = order[i] / side;

            pts[x][y] = new UntanglePoint(x, y);
        }

        // connect the close neighbours
        DoInitialGridPass();

        // Try to connect together any disconnected sub-meshes
        ConnectSubGrids();

        // Detect any crossing lines and clean then up
        CleanupCrossovers();

        ////////////////////////////////////////////////////////////////
        // Scramble the grid by arrange the point in a circle in a random order
        ArrangeInCircle();

        ((UntanglePanel) jPanel1).SetSolved(false);
        checkSolution();

        // Copy our work to the panel for display
        ((UntanglePanel) jPanel1).setGrid(pts);

        // enable buttons
        solved = false;
        needsSave= false;

        EnableControls();
    }

    // Enable the controls when the first untangle mesh is generated
    public void EnableControls() {
        jIntersectChk.setEnabled(true);
        jQueryChk.setEnabled(true);
        btnSolve.setEnabled(true);
        SaveBtn.setEnabled(true);
    }

    // Arranges the points in a random order in a circle
    public void ArrangeInCircle() {
        int[] order = GenerateOrder(size, size);
        int item = 0;

        for (UntanglePoint[] pt_col : pts) {
            for (UntanglePoint pt : pt_col) {
                if (pt != null) {
                    double angle = (Math.PI * 2 * order[item++]) / size;

                    double x_pos = ((Math.cos(angle) / 2) + 0.5) * (side - 1);
                    double y_pos = ((Math.sin(angle) / 2) + 0.5) * (side - 1);

                    pt.MoveTo((int) (x_pos * DISPLAY_FACTOR), (int) (y_pos * DISPLAY_FACTOR));
                }
            }
        }
    }

    // Checks to see if a solution found, also counts the number of intersecting lines
    public void checkSolution() {

        needsSave = true;

        boolean count_intersections = jIntersectChk.getState();
        if (pts != null) {
            // Convert the points to line segments (the line segments class has the
            //  intersection check code.
            List<LineSegment> lines = EnumerateDisplayLines();
            int intersect = 0;

            // Scane the line pairs looking for intersections
            for (int i = 0; i < lines.size(); i++) {
                LineSegment l1 = lines.get(i);
                for (int j = i + 1; j < lines.size(); j++) {
                    LineSegment l2 = lines.get(j);

                    if (l1.intersect(l2)) {
                        // If not counting intersections can drop out on
                        //   first intersection found, otherwise mark the
                        //   intersecting lines
                        if (count_intersections) {
                            intersect++;
                            l1.crosses++;
                            l2.crosses++;
                        } else {
                            return;
                        }

                    }
                }
            }

            // pass the line to the panel, as this conatins the intersecting line info
            //  used to draw intersecting lines in red
            ((UntanglePanel) jPanel1).lines = lines;

            if (count_intersections) {
                IntersectLbl2.setText(Integer.toString(intersect));
            }

            // Check is solution is found
            if (intersect == 0 && !solved) {
                String msg = "<html><b>*** CONGRATULATIONS ***</b><BR>You have successfully untangled the lines";
                JOptionPane.showMessageDialog(null, msg);
                solved = true;
                ((UntanglePanel) jPanel1).SetSolved(true);
            }
        }
    }

    // first psss in grid, connect neighbourug squares
    public void DoInitialGridPass() {
        // Do initial grid pass
        
        // For each point
        for (int x = 0; x < side; x++) {
            for (int y = 0; y < side; y++) {

                if (pts[x][y] != null) {
                    
                    // Check immediate neighbours in all 8 directions
                    for (int xp = -1; xp <= 1; xp++) {
                        for (int yp = 0; yp <= 1; yp++) {
                            if ((x == 0 && xp == -1) || (y == 0 && yp == -1)
                                    || (x == side - 1 && xp == 1) || (y == side - 1 && yp == 1)
                                    || (xp == 0 && yp == 0)) {
                                continue;
                            }

                            // If found connect
                            if (pts[x + xp][y + yp] != null) {
                                pts[x][y].AddPoint(pts[x + xp][y + yp]);
                                pts[x + xp][y + yp].AddPoint(pts[x][y]);
                            }
                        }
                    }
                }
            }
        }
    }

    // Add all points connected to the selected point to the grid
    public void AddConnected(List<UntanglePoint> list, UntanglePoint pt) {

        if (list.contains(pt)) {
            return;
        }

        int start = list.size();

        list.add(pt);  // Add currnt point
        
        // Check all points we are connected to
        for (int i = start; i < list.size(); i++) {
            UntanglePoint current = list.get(i);

            for (UntanglePoint connected : current) {
                if (!list.contains(connected)) {
                    list.add(connected);
                }
            }
        }

    }

    // Does a basic connection test, given 2 points makes sure there isn't a point between them
    public boolean CanConnect(UntanglePoint p1, UntanglePoint p2) {
        int xp1 = p1.GetPoint().x;
        int xp2 = p2.GetPoint().x;
        int yp1 = p1.GetPoint().y;
        int yp2 = p2.GetPoint().y;

        int xd = Math.abs(xp2 - xp1);
        int yd = Math.abs(yp2 - yp1);

        if ((xd >= 2 || yd >= 2) && (xd == 0 || yd == 0 || xd == yd)) {
            int xsgn = (xd > 0) ? (xp2 - xp1) / xd : 0;
            int ysgn = (yd > 0) ? (yp2 - yp1) / yd : 0;

            int d = Math.max(xd, yd);

            for (int i = 1; i < d; i++) {
                 if (pts[xp1 + i * xsgn][yp1 + i * ysgn] != null) {
                   return false;
                }
            }

        }

        return true;
    }

     // Attempt to connect in disconnected points and island to form a single grid
   public void ConnectSubGrids() {
        List<UntanglePoint> connected = new ArrayList<>();

        // Find a point connected to 2 or more others
        for (int x = 0; x < side; x++) {
            for (int y = 0; y < side; y++) {
                if (pts[x][y] != null && pts[x][y].Connections() >= 2) {
                    AddConnected(connected, pts[x][y]);
                    break;
                }
            }
        }

        // Search for unconnected points/sub-grids
        for (int x = 0; x < side; x++) {
            for (int y = 0; y < side; y++) {
                if (pts[x][y] != null && (!connected.contains(pts[x][y]) || pts[x][y].Connections() < 3)) {
                    int d1 = 0;
                    int d2 = 0;
                    int d3 = 0;
                    UntanglePoint p1 = null;
                    UntanglePoint p2 = null;
                    UntanglePoint p3 = null;

                    // locate the closest 3 connected points
                    for (UntanglePoint check : connected) {
                        int dist = check.Distance2(pts[x][y]);

                        if (dist == 0) {
                            continue;
                        }

                        if ((p1 == null || (p3 != null && dist < d1))
                                && CanConnect(check, pts[x][y])) {

                            p1 = check;
                            d1 = dist;
                        } else if ((p2 == null || (p3 != null && dist < d2))
                                && CanConnect(check, pts[x][y])) {
                            p2 = check;
                            d2 = dist;
                        } else if ((p3 == null || dist < d3)
                                && CanConnect(check, pts[x][y])) {
                            p3 = check;
                            d3 = dist;
                        }
                    }

                    // Add the points
                    if (p1 != null || p2 != null || p3 != null) {
                        if (p1 != null) {
                            pts[x][y].AddPoint(p1);
                            p1.AddPoint(pts[x][y]);
                        }

                        if (p2 != null) {
                            pts[x][y].AddPoint(p2);
                            p2.AddPoint(pts[x][y]);
                        }

                        if (p3 != null) {
                            pts[x][y].AddPoint(p3);
                            p3.AddPoint(pts[x][y]);
                        }

                        AddConnected(connected, pts[x][y]);
                    }
                }
            }
        }
    }

   // Convert the points into line segments (for calculation)
    public List<LineSegment> EnumerateLines() {
        // Build an array of lines
        List<LineSegment> lines = new ArrayList<>();
        for (int x = 0; x < side; x++) {
            for (int y = 0; y < side; y++) {
                if (pts[x][y] != null) {
                    for (UntanglePoint check : pts[x][y]) {
                        int xp1 = pts[x][y].GetPoint().x;
                        int xp2 = check.GetPoint().x;
                        int yp1 = pts[x][y].GetPoint().y;
                        int yp2 = check.GetPoint().y;

                        // Only check lines in 1 direction
                        if (xp1 < xp2 || (xp1 == xp2 && yp1 < yp2)) {
                            lines.add(new LineSegment(pts[x][y].GetPoint(), check.GetPoint()));
                        }
                    }
                }
            }
        }
        return (lines);
    }

   // Convert the points into line segments (for display)
    public List<LineSegment> EnumerateDisplayLines() {
        // Build an array of lines
        List<LineSegment> lines = new ArrayList<>();
        for (int x = 0; x < side; x++) {
            for (int y = 0; y < side; y++) {
                if (pts[x][y] != null) {
                    for (UntanglePoint check : pts[x][y]) {
                        int xp1 = pts[x][y].GetDisplayPoint(false).x;
                        int xp2 = check.GetDisplayPoint(false).x;
                        int yp1 = pts[x][y].GetDisplayPoint(false).y;
                        int yp2 = check.GetDisplayPoint(false).y;

                        // Only check lines in 1 direction
                        if (xp1 < xp2 || (xp1 == xp2 && yp1 < yp2)) {
                            lines.add(new LineSegment(pts[x][y].GetDisplayPoint(false), check.GetDisplayPoint(false)));
                        }
                    }
                }
            }
        }
        return (lines);
    }

    // Check the completed grid for cross-overs. This is dome in 2 passes
    //  Pass 1: remove lines which cross multiple times
    //  Pass 2: if a cross-over still found remove a rendomly selected line
    public void CleanupCrossovers() {
        // Scan and clean up simple crossovers, there will be a few of these
        for (int x = 0; x < side - 1; x++) {
            for (int y = 0; y < side - 1; y++) {
                if (pts[x][y] != null && pts[x + 1][y] != null
                        && pts[x][y + 1] != null && pts[x + 1][y + 1] != null) {
                    if (rand.nextBoolean()) {
                        pts[x][y].RemovePoint(pts[x + 1][y + 1]);
                        pts[x + 1][y + 1].RemovePoint(pts[x][y]);
                    } else {
                        pts[x][y + 1].RemovePoint(pts[x + 1][y]);
                        pts[x + 1][y].RemovePoint(pts[x][y + 1]);
                    }
                }
            }
        }

        // Build an array of lines
        List<LineSegment> lines = EnumerateLines();

        // Scan for cross overs initially removing lines which cross 2 or more other lines
        for (int i = 0; i < lines.size(); i++) {
            LineSegment l1 = lines.get(i);
            for (int j = i + 1; j < lines.size(); j++) {
                LineSegment l2 = lines.get(j);

                //   System.out.printf("%s with %s \n", l1.toString(), l2.toString());
                if (l1.intersect(l2)) {
                    LineSegment s = null;
                    l1.crosses++;
                    l2.crosses++;

                    if (l1.crosses > 1) {
                        s = l1;
                        l2.crosses--;
                    }
                    if (l2.crosses > 1) {
                        s = l2;
                        l1.crosses--;
                    }

                    //LineSegment s = (rand.nextBoolean()) ? l1 : l2;
                    if (s != null) {
                        pts[s.end1.x][s.end1.y].RemovePoint(pts[s.end2.x][s.end2.y]);
                        pts[s.end2.x][s.end2.y].RemovePoint(pts[s.end1.x][s.end1.y]);
                        lines.remove(s);
                    }
                }
            }
        }

        // Clear the crosses counts
        lines.forEach((l) -> {
            l.crosses = 0;
        });

        // Re-scan removing any remaining cross overs
        for (int i = 0; i < lines.size(); i++) {
            LineSegment l1 = lines.get(i);
            for (int j = i + 1; j < lines.size(); j++) {
                LineSegment l2 = lines.get(j);

                if (l1.intersect(l2)) {
                    LineSegment s;
                    if (rand.nextBoolean()) {
                        s = l1;
                        i--;
                        j = lines.size();
                    } else {
                        s = l2;
                        j--;
                    }

                    pts[s.end1.x][s.end1.y].RemovePoint(pts[s.end2.x][s.end2.y]);
                    pts[s.end2.x][s.end2.y].RemovePoint(pts[s.end1.x][s.end1.y]);
                    lines.remove(s);

                }
            }
        }

        ((UntanglePanel) jPanel1).lines = lines;
    }

    // Handle the user pressing the show solution button
    private void btnSolveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSolveActionPerformed
        ((UntanglePanel) jPanel1).ToggleSolution();
    }//GEN-LAST:event_btnSolveActionPerformed

    // Handle the user pressing the create button
    private void btnCreateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCreateActionPerformed

        // Get the number of points
        try {
            size = Integer.parseInt(jGridSizeText.getText());

        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Size must be a numeric value in the range 10 to 200");
            return;
        }

        if (size < 10 || size > 200) {
            JOptionPane.showMessageDialog(null, "Size must in the range 10 to 200");
            return;
        }

        if (CheckSave()) {
            GenerateGrid();
        }
    }//GEN-LAST:event_btnCreateActionPerformed

    // Handle the user selecting the query mode
    private void QueryChkItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_QueryChkItemStateChanged
        ((UntanglePanel) jPanel1).SetQuery(jQueryChk.getState());
    }//GEN-LAST:event_QueryChkItemStateChanged

    // handle the user pressing the show intersections button
    private void IntersectChkItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_IntersectChkItemStateChanged
        boolean state = jIntersectChk.getState();
        ((UntanglePanel) jPanel1).ToggleIntersecting();

        IntersectLbl1.setVisible(state);
        IntersectLbl2.setVisible(state);
        jPanel2.validate();

        checkSolution();
    }//GEN-LAST:event_IntersectChkItemStateChanged


    // Check whether a save is required on exit or loading a new file
    private boolean CheckSave() {
        if (needsSave) {
            String message = "Do you want to save changes?\r\n\r\nSelect cancel to abort.";
            int option = JOptionPane.showConfirmDialog(null, message, "Save", JOptionPane.YES_NO_CANCEL_OPTION);

            if (option == JOptionPane.YES_OPTION) {
                SaveBtnActionPerformed(null);

                if (needsSave) {
                    JOptionPane.showMessageDialog(null, "Save Failed", "Error", JOptionPane.ERROR_MESSAGE);
                    return false;
                }
            } else if (option == JOptionPane.CANCEL_OPTION) {
                return false;
            }
        }
        return true;
    }

    // Handle the load button
    private void LoadBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_LoadBtnActionPerformed
        if (!CheckSave()) {
            return;
        }

        // Popup dialog to prompt user for a map file
        JFileChooser chooser = new JFileChooser();
        FileNameExtensionFilter filter = new FileNameExtensionFilter(
                "Untangle Files", EXTENSION);
        chooser.setFileFilter(filter);
        int returnVal = chooser.showOpenDialog(this);

        // If the user selected one
        if (returnVal == JFileChooser.APPROVE_OPTION) {

            try {
                // Get file path
                String filename = chooser.getSelectedFile().getAbsolutePath();

                // Open file
                FileInputStream fileIn = new FileInputStream(filename);
                ObjectInputStream in = new ObjectInputStream(fileIn);

                pts = (UntanglePoint[][]) in.readObject();  // read the data
                side = pts.length;

                // Close the file
                in.close();
                fileIn.close();
            } catch (IOException | ClassNotFoundException i) {
                JOptionPane.showMessageDialog(null, "Failed to load map file\r\n\r\n" + i.toString(), "Error",
                        JOptionPane.ERROR_MESSAGE);
                return;
            }

            // Show the controls and redraw
            ((UntanglePanel) jPanel1).setGrid(pts);
            solved = false;
            checkSolution();
            needsSave = false;
            EnableControls();
            jPanel1.invalidate();
            jPanel1.repaint();
        }
    }//GEN-LAST:event_LoadBtnActionPerformed

    // GHandle the user pressing the save button
    private void SaveBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SaveBtnActionPerformed

        // Popup dialog to prompt user for a map file name to save to
        JFileChooser chooser = new JFileChooser();
        FileNameExtensionFilter filter = new FileNameExtensionFilter(
                "Untangle Files", EXTENSION);
        chooser.setFileFilter(filter);

        int returnVal = chooser.showSaveDialog(this);

        // If the user selected one
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            try {
                // If the user selected one
                String filename = chooser.getSelectedFile().getAbsolutePath();
                if (!filename.endsWith("." + EXTENSION)) {
                    filename += "." + EXTENSION;
                }

                // Open file
                FileOutputStream fileOut = new FileOutputStream(filename);
                ObjectOutputStream out = new ObjectOutputStream(fileOut);

                out.writeObject(pts); // Save the points

                // close the file
                out.close();
                fileOut.close();

                needsSave = false;

            } catch (IOException i) {
                JOptionPane.showMessageDialog(null, "Failed to save map file\r\n\r\n" + i.toString(), "Error",
                        JOptionPane.ERROR_MESSAGE);
            }
        }
    }//GEN-LAST:event_SaveBtnActionPerformed

    // handle the Windows rsizing
    private void jPanel1ComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_jPanel1ComponentResized
         ((UntanglePanel) jPanel1).ClearRubberBand();
    }//GEN-LAST:event_jPanel1ComponentResized

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(UntangleFrm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new UntangleFrm().setVisible(true);
            }
        });

    }

    private final Random rand = new Random(System.currentTimeMillis());
    private int side = 0;   // number of point on each side of the solution square
    private int size = 0;   // Total nuber of points
    private UntanglePoint[][] pts = null;  // The actual points
    private boolean solved = false;
    private boolean needsSave = false;    // Whether any savable change has been made
    private static final String EXTENSION = "map";

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private java.awt.Label IntersectLbl1;
    private java.awt.Label IntersectLbl2;
    private java.awt.Button LoadBtn;
    private java.awt.Button SaveBtn;
    private java.awt.Button btnCreate;
    private java.awt.Button btnSolve;
    private java.awt.TextField jGridSizeText;
    private java.awt.Checkbox jIntersectChk;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private java.awt.Checkbox jQueryChk;
    private java.awt.Label label1;
    // End of variables declaration//GEN-END:variables
}
